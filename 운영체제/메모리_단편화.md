## 1. 메모리 단편화란?
#### - RAM에서 메모리의 공간이 작은 조각으로 나뉘어져 사용가능한 메모리가 충분히 존재하지만 할당(사용)이 불가능한 상태
- RAM(Random Access Memory)
	- 데이터를 저장하거나 저장된 데이터를 읽어내는 기억 장치
 	- 디스크와 달리 전원이 꺼지면 데이터는 지워짐
  	- 메모리의 용량이 부족할 경우 하드디스크에서 직접 데이터를 읽어오게 되는데, 이 때 작업 속도는 매우 느려지게 되기 때문에 메모리가 부족한 경우 용량 증설하면 속도가 향상될 수 있음.
    
  
#### - 메모리 단편화로 일어날 수 있는 현상
   - 총 메모리 공간은 충분하지만 실제 사용이 불가능할 수 있다.
   - 실제 사용 가능한 공간이 줄어들어 시스템 성능 저하를 일으킬 수 있다.
        - 실제 사용할 수 있는 공간을 찾는 과정 필요
        - 잦은 페이지 교체
        - swapping
    
#### - 메모리 단편화는 내부 단편화와 외부 단편화로 구분 가능하다.

---
## 2. 내부 단편화(Internal Fragmentation)
![Internal](https://velog.velcdn.com/images/hanhs4544/post/91bfb9bd-2bcd-4ebc-821f-3886c1d998a3/image.png)

- 메모리를 할당할 때 프로세스가 필요한 양보다 더 큰 메모리가 할당되어 메모리 공간이 낭비되는 상황
- 예를 들어 메모장을 틀었는데 OS가 10Kb 할당, 하지만 7kb만 사용하고 있을 때 필요 이상으로 프로세스가 메모리를 할당받았음 -> 내부 단편화 3kb만큼 생김


</br>

## 3. 외부 단편화(External Fragmentation)
![External](https://velog.velcdn.com/images/hanhs4544/post/3b75824b-d361-411b-b087-de58f6d2e221/image.png)

- 메모리가 할당 및 해제 작업의 반복으로 작은 메모리가 중간중간 존재하게 된다. 이 때 중간에 생긴 사용하지 않는 메모리가 많이 존재해서 **총 메모리 공간은 충분하지만 실제로 할당이 불가한 상황**
- 남은 공간은 12K이나 프로세스 E를 분할하여 넣을 수 없으므로 할당할 수 없게 된다.

</br>

----

</br>

## 4. 메모리 파편화 문제 해결 방법 
#### - 압축, 통합, 페이징, 세그먼테이션의 방식이 있다.
### ① 압축 (Compaction)
![Compaction](https://velog.velcdn.com/images/hanhs4544/post/d8999881-4ed4-4780-ba04-ca5568220148/image.png)
- 메모리 공간을 재배치하여 단편화로 인해 분산되어 있는 메모리 공간들을 하나로 합치는 기법
- ex) 디스크 조각 모음

</br>

### ② 통합 (Coalescing)
![Coalescing](https://velog.velcdn.com/images/hanhs4544/post/39ea36ae-619f-4682-9ec7-71e6dc83e2e9/image.png)
- 단편화로 인해 분산된 메모리 공간들을 인접해 있는 것끼리 통합시켜 큰 메모리 공간으로 합치는 기법
- 압축은 재배치되는 것, 통합은 인접 공간끼리 통합된다는 것에서 차이가 있음

</br>

### ③ 페이징 (Paging)
**- 가상 메모리 사용, 외부 단편화 해결, 내부 단편화 존재**
![Paging](https://velog.velcdn.com/images/hanhs4544/post/84edf708-4818-45e3-9672-d76e1e5a1091/image.png)
- 페이지 : 가상메모리를 같은 크기의 블록으로 나눈 것
- 프레임 : RAM을 페이지와 같은 크기로 나눈 것

=> 사용하지 않는 프레임을 페이지에 옮기고, 필요한 메모리를 페이지 단위로 프레임에 옮기는 것
- 페이지와 프레임을 대응시키기 위해 페이지 매핑과정이 필요하기 때문에 페이징 테이블을 만든다.
- 연속적이지 않은 공간도 활용할 수 있기 때문에 외부 단편화 문제를 해결할 수 있다.
- 페이지 단위에 알맞게 꽉채워 쓰는게 아니므로 내부 단편화 문제는 여전히 있다.
- **페이지 단위를 작게하면 내부 단편화 문제도 해결할 수 있겠지만 대신 페이지 매핑 과정이 많아져 오히려 효율이 떨어질 수 있다.**

-  페이지의 크기를 결정하는 기준
	- 내부 단편화
	- Page-in, Page-out 시간 - I/O Overhead
	- 페이지 테이블(Page Table) 크기
	- 메모리 해상도(Memory resolution) - 필요한 내용만 메모리에 담을 수 있는 정도
	- 페이지 부재(Page Fault) 발생 확률

- 페이지 크기가 작을 수록 좋은 기준
: 내부 단편화 - 페이지가 작을 수록 버려지는 메모리의 내부 공간(내부 단편화)도 작아짐
: 메모리 해상도 - 페이지가 크면 불필요한 영역까지 함께 적재될 수 밖에 없다. 반대로 적을 수록 필요한 부분만 메모리에 적재되는 정밀도가 증가한다.

- 페이지 크기가 클 수록 좋은 기준
: Page-in, Page-out 시간 - I/O시간은 대부분 디스크의 헤드 이동시간이다. 페이지가 클 수록 한 번 이동해서 많은 데이터를 읽어올 수 있는 장점이 있다.
: Page Table Size - 페이지의 크기가 클 수록 테이블의 row 수는 적게 된다.
: Page Fault 발생 확률 - 페이지가 클 수록 하나의 페이지 내에 많은 내용을 담고 있기 때문에 페이지 재사용 가능성이 높게 되고 메모리 지역성에 의해 페이지 부재도 덜 발생하게 된다.

</br>

### ④ 세그먼테이션(Segmentation)
**- 가상 메모리 사용, 내부 단편화 해결, 외부 단편화 존재**
![Segmentation](https://velog.velcdn.com/images/hanhs4544/post/2104f437-1c2a-4c60-945f-5803db6ce396/image.png)

- 가상 메모리를 서로 크기가 다른 논리적 단위인 세그먼트로 분할해서 메모리를 할당하여 실제 메모리 주소로 변환하게 하는 방법
- 각 세그먼트는 연속적인 공간에 저장되어 있다.
- 세그먼트들의 크기가 다르기 때문에 미리 분할해 둘 수 없고, 메모리에 적재될 때 빈 공간을 찾아 할당하는 기법
- 매핑을 위해 세그먼트 테이블 필요 -> 각 세그먼트의 시작 주소와 크기 정보 수록
- 프로세스가 필요한 메모리만큼 할당해주기 때문에 내부 단편화는 일어나지 않으나 여전히 중간에 프로세스가 메모리를 해제하면 생기는 구멍(hole), 즉 외부 단편화 문제는 여전히 존재함.

</br>

```text
[참고자료]
https://jeong-pro.tistory.com/91
https://truemind5.blogspot.com/2017/05/17.html
https://yongj.in/rust%20os/rust-os-intoduction-to-paging/
```
