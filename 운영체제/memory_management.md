# 메모리
## 메인 메모리 (주기억장치)
- CPU가 직접 접근할 수 있는 기억장치, 보조기억장치에 저장된 프로그램은 메인 메모리에 적재되야 실행할 수 있다.
- 메모리 종류
    1. 레지스터 : 제일 빠른 메모리로 CPU 계산과정의 일부로 작동
    2. 캐시 메모리(SRAM) : 레지스터 다음으로 빠른 메모리로 L1, L2, L3 캐시 등 여러 단계로 나뉨
    3. 메인 메모리(DRAM) : 캐시 메모리 다음으로 빠름
    4. 하드디스크(HDD) : 보조기억장치, 제일 느림

<br>

## 가상 메모리
- 메모리 관리 기법중의 하나로 각 프로그램에 실제 메모리 주소가 아닌 가상의 메모리 주소를 주는 기법
- 메모리 공간은 한정적이므로 사용자에게 더 많은 메모리를 제공하기 위해 가상 주소를 사용
- 메모리 관리 장치(Memory Management Unit, MMU)는 가상 주소를 이용해 실제 데이터가 담겨 있는 주소로 변환해줌
![가상메모리](https://upload.wikimedia.org/wikipedia/commons/thumb/6/6e/Virtual_memory.svg/220px-Virtual_memory.svg.png)

<br>

# 메모리 관리 기법
## 메모리 관리 기법 사용 이유
- 다중 프로그래밍 시스템에서 여러 프로세스를 수용하기 위해서는 주기억장치를 동적 분할하는 메모리 관리 작업이 필요

<br>

## 연속 메모리 관리
- 프로그램 전체가 하나의 커다란 공간에 연속적으로 할당
- 고정 분할 기법 : 주기억장치가 고정된 파티션으로 분할(내, 외부 단편화 발생)
- 가변 분할 기법 : 스케줄러에 의하여 선택된 프로그램 크기만큼을 가용한 메모리 공간으로부터 배정하여 할당(외부 단편화 발생)
- 가변 분할 공간 할당 정책
    - 최초적합(First Fit) : 프로그램이 적재 될 수 있는 빈블록들 중 첫 번째로 발견된 블록에 적재
    - 최적 적합(Best Fit) : 빈 블록들 중 프로그램 크기와 가장 잘 맞는 블록을 찾아 적재
    - 최악 적합(Worst Fit) : 적재 가능한 빈 블록들 중 가장 큰 크기를 가진 빈 블록에 적재
    ![image](https://user-images.githubusercontent.com/47655983/171576351-db10b074-0d41-4d2a-a99d-c41d719aa7f1.png)

<br>

## 불연속 메모리 관리
- 프로그램의 일부가 서로 다른 주소 공간에 할당될 수 있는 기법
    - 페이지 : 고정 사이즈의 작은 프로세스 조각(논리적 메모리)
    - 프레임 : 페이지 크기와 같은 주기억장치 메모리 조각(물리적 메모리)
    - 세그먼트 : 서로 다른 크기를 가진 논리적 블록이 연속적 공간에 배치되는 것
- 고정 크기 : 페이징
- 가변 크기 : 세그먼테이션
- 단편화
    - 내부 단편화 : 메모리를 할당할 때 프로세스가 필요한 양보다 더 큰 메모리가 할당되어 메모리 공간이 낭비되는 현상
    ![image](https://user-images.githubusercontent.com/47655983/171577997-3092f19a-a259-42e1-ab2b-16cce9c872f3.png)
    ![image](https://user-images.githubusercontent.com/47655983/171578081-3746361d-937f-4428-8192-24d4cf0c40ac.png)
    - 외부 단편화 : 총 여유 공간은 충분하지만 메모리가 작게 쪼개어져 있어서 메모리를 할당할 수 없는 현상
    ![image](https://user-images.githubusercontent.com/47655983/171578166-715066a0-5e7b-478d-a461-7ee0e475a3fb.png)

- 단순 페이징
    - 각 프로세스는 프레임들과 같은 길이를 가진 균등 페이지로 나뉨
    - 물리 메모리는 프레임으로 나뉘어짐
    - 외부 단편화 X
    - 할당은 항상 프레임의 정수 배로 할당되는데 만약 프로세스가 프레임의 정수 배보다 살짝 작다면 할당된 마지막 프레임은 전부 사용되지 않고 남아버리는 문제 발생(소량의 내부 단편화 존재)
    ![image](https://user-images.githubusercontent.com/47655983/171590733-a36a6596-d64b-45e7-8ee5-51632207547b.png)
- 단순 세그먼테이션
    - 각 프로세스는 여러 세그먼트들로 나뉨(텍스트, 데이터, BSS, 스택)
    - 내부 단편화 X, 메모리 사용 효율 개선, 동적 분할을 통한 오버헤드 감소
    - 세그먼트들이 적재, 제거 되는 일이 반복되면 자유 공간들이 수많은 작은 조각들로 나뉘어져 못쓰게 될 수 있음(외부 단편화 존재)
    ![image](https://user-images.githubusercontent.com/47655983/171591685-17cdc3bd-076d-4b73-9c91-58e3f2f7b7ec.png)

## 페이지 교체 알고리즘
- FIFO(First-In First-Out) 알고리즘
    - 시간적으로 가장 먼저 메모리에 적재된 페이지를 교체를 위한 페이지로 선택하는 것
    - Belady의 이상현상
        - 프레임의 개수가 증가 될수록 페이지 폴트의 횟수는 줄어드는 것이 일반적
        - FIFO방식에서는 프레임의 개수가 증가되는 경우 오히려 페이지 폴트가 증가되는 현상이 발견되는데 이 현상을 Belady의 이상현상이라고 함
        ![image](https://user-images.githubusercontent.com/47655983/171616920-921ed6fe-dc79-42d5-8d9c-62d25cddb5c7.png)
- OPT(Optimal Page Replacement) 알고리즘
    - 현재의 시점에서 향후 가장 오랫동안 사용되지 않을 페이지를 교체 대상으로 선택하는 방법
    - 가장 이상적이지만 미래를 모두 예측해서 프로그램을 운영해야 하기 때문에 구현이 어려움
    - 실제 구현 가능한 다른 방법들과의 성능 비교를 위해 사용
- LRU(Least Recently Used) 알고리즘
    - 현재 시점에서 가장 최근에 사용되지 않은 페이지를 교체하는 기법
    - 최근에 사용한 페이지는 향후에도 재사용될 가능성이 높다는 시간적 구역성(Temporal Locality)을 기반으로 구성
- LFU(Least Frequently Used) 알고리즘
    - 가장 작은 참조 횟수를 가지는 페이지를 교체 대상으로 하는 방식
    - NFU(Not Frequently Used)라고도 불림
- 교체방식
    - Global 교체
        - 메모리 상의 모든 프로세스 페이지에 대해 교체
    - Local 교체
        - 메모리 상의 자기 프로세스 페이지에서만 교체