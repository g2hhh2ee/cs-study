# 1. 브라우저가 하는 일

html, css, js를 이용하여 웹 브라우저는 페이지를 보여주게 된다. 이때 브라우저에는 어떤 일이 일어날까? 

하나의 웹페이지를 보여주기 위해서는 브라우저가 많은 일들을 처리한다. 먼저, 브라우저의 공통적인 구조에 대해 간단하게 살펴보자. (7가지)

![image](https://user-images.githubusercontent.com/57996351/185381821-8e56c23d-1ee2-47e8-ab66-351c72114b28.png)

브라우저의 주요 구성 요소는 다음과 같다.

1. 사용자 인터페이스 - 주소 표시줄, 이전/다음 버튼, 북마크 메뉴 등. 요청한 페이지를 보여주는 창을 제외한 나머지 모든 부분이다.
2. 브라우저 엔진 - 사용자 인터페이스와 렌더링 엔진 사이의 동작을 제어.
3. 렌더링 엔진 - 요청한 콘텐츠를 표시. 예를 들어 HTML을 요청하면 HTML과 CSS를 파싱하여 화면에 표시함.
4. 통신 - HTTP 요청과 같은 네트워크 호출에 사용됨. 이것은 플랫폼 독립적인 인터페이스이고 각 플랫폼 하부에서 실행됨.
5. UI 백엔드 - 콤보 박스와 창 같은 기본적인 장치를 그림. 플랫폼에서 명시하지 않은 일반적인 인터페이스로서, OS 사용자 인터페이스 체계를 사용.
6. 자바스크립트 해석기 - 자바스크립트 코드를 해석하고 실행.
7. 자료 저장소 - 이 부분은 자료를 저장하는 계층이다. 쿠키를 저장하는 것과 같이 모든 종류의 자원을 하드 디스크에 저장할 필요가 있다. HTML5 명세에는 브라우저가 지원하는 '[웹 데이터 베이스](http://www.html5rocks.com/en/features/storage)'가 정의되어 있다.

# 2. **Rendering Engine** 렌더링 엔진

렌더링 엔진의 역할은 요청 받은 내용을 브라우저 화면에 표시하는 일이다.

**렌더링 엔진의 목표**

1. HTML, CSS, JavaScript, 이미지 등 웹 페이지에 포함된 모든 요소들을 화면에 보여준다.
2. **업데이트**가 필요할 때 **효율적으로 렌더링**을 할 수 있도록 자료 구조를 생성한다.
    
    ❗️여기서 업데이트란, 사용자의 동작으로 입력이 발생 하던가, 스크롤이 생김, 애니메이션 동작, 비동기 요청으로 인한 데이터 로딩 등을 말함.
    

**렌더링 엔진의 동작과정**

![image](https://user-images.githubusercontent.com/57996351/185381878-e2c47451-95d9-4596-9ff0-32c77638c2ac.png)

먼저 브라우저에서 사용자가 요청한 웹 페이지 문서를 불러오고 파싱한다. 어휘분석을 통해 html5 표준에서 지정된 고유한 토큰으로 변환된다. 

<html> 

예를들어 StartTag html 이라는 토큰은 HTML이라는 태그가 열렸다라는 의미를 가진다. 

</html>

EndTag html HTML이라는 태그가 닫혔다라는 의미를 가진다.

- DOM 트리 생성

다음으로 브라우저의 렉싱 과정(구문 분석)을 통해서 토큰이 해당 속성과 규칙을 정의하는 노드 객체로 변환된다. 그리고 **각 노드가 서로 연관성을 가질 수 있도록 트리를 생성하는데 이게 바로 'DOM 트리'**라 한다. 

html 문서의 모든 것은 이 DOM을 구성한다. 최상위에는 document 객체가 들어가고 태그는 element노드가 되고, 태그의 요소는 attribute 노드, 태그의 텍스트는 텍스트 노드가 되어 트리구조를 생성한다. 이외의 주석도 comment노드가 되어 생성한다. 브라우저는 html 문서를 파싱하는 과정에서 css나 js와 같은 파일을 추가로 요청하기도 한다. 

- CSSOM 트리 생성

html을 DOM트리로 만드는 과정과 비슷하게 css또한 CSSOM이라는 트리가 만들어진다. CSSOM은 DOM이 어떻게 화면에 표시될지를 알려준다.  CSS도 위에서 아래로 스타일 규칙이 정해지기 때문에 동일하게 트리구조를 갖는다. 

- Render 트리 생성

그리고 렌더링 엔진이 DOM 트리와 CSSOM 트리를 합쳐서 **렌더 트리(Render Tree)**라는 것을 만든다. **렌더 트리는 화면에 표시되어야 할 모든 노드의 컨텐츠, 스타일 정보를 포함하고 있는 트리다.**

렌더 트리가 만들어지는 과정을 대략적으로 설명을 하자면, document 객체부터 각 노드를 순회하면서 각각에 맞는 CSSOM을 찾아서 규칙을 적용한다. 그러면서 렌더와 관련한 요소들을 렌더 트리에 포함시킨다.

이때 **meta태그나 display:none 속성**을 가진 요소들은 렌더와 관계가 없기 때문에 **렌더 트리에 포함되지 않는다.**

- Layout

렌더트리가 생성되었다면 **Layout**이라는 과정이 시작된다. (**Reflow**라고 부르기도 함) 

박스 모델에 따라서 텍스트나 요소의 박스가 화면에서 차지하는 영역이나 여백 그리고 이외의 스타일 속성이 계산된다.

이때 **CSS에서 %나 em같은 상대적인 단위**를 사용했을때는 이게 **뷰포트에 맞춰서 픽셀단위로 변환된**다. 

- Paint

레이아웃 과정에서 렌더링 엔진이 각 요소들이 어떻게 생겼고 이를 어떻게 보여주는지 알게 되면 마지막에 화면에 실제 픽셀로 그려지도록 변환하는 과정을 거치는데 이것이 바로 **'페인트(paint)'** 과정이다. 이 과정에서 렌더 트리에 포함된 요소들이나 텍스트, 이미지들이 실제 픽셀로 그려진다.

---

# 3. UI가 업데이트 되는 3가지 상황

critical rendering path 시간을 줄이면 브라우저가 웹 페이지를 보여주는 데 걸리는 시간을 줄일 수 있다. 하지만 사용자 동작으로 css가 변경되거나 애니메이션 재생이 일어난다면 어떻게 될까?

JS → Style → Layout → Paint → Composite

- 레이아웃이 다시 변경되는 경우

**요소의 크기나 위치가 바뀔때 혹은 브라우저창이 크기가 바뀌었을 때** js, style, layout, paint, composite과정이 발생한다. 

- 페인트부터 다시 발생되는 경우

배경 이미지나 텍스트 색상, 그림자와 같이 레이아웃 **수치를 변화시키지 않는 스타일에 변경**이 일어났을 때 발생한다. 이때는 js, style, paint, composite과정을 거친다. 

- 레이어의 합성만 다시 발생하는 경우

레이어는 페인팅할 영역을 나눠놓은 것을 의미한다. 크롬의 경우 레이아웃 과정 이후, 정해진 기준에 의해 브라우저가 레이어를 생성한다. 그리고 렌더 트리에 있는 노드 객체는 생성된 레이어에 포함된다. 이 레이어는 트리형태로 구성되고 렌더링 엔진이 각 레이어를 페인팅 과정에서 그려준 후 하나의 비트맵으로 합성하여 페이지를 완성한다. 이때 layout과 paint를 하지 않으므로 성능이 가장 좋다.



- 요약

사용자가 요청 & 응답한 문서 파싱 -> DOM트리 생성 -> CSSOM 트리 생성 -> 렌더 트리 생성 -> 레이아웃 -> 페인트

만약 css 변경 or 애니메이션이 재생된다면 -> 레이아웃을 바꾸거나, 페인트를 다시 발생시키거나, 합성만 다시 진행

# 📝 정리

1. HTML 마크업을 처리하고 DOM 트리를 빌드한다. (DOM 파싱)
2. CSS 마크업을 처리하고 CSSOM 트리를 빌드한다. (CSS 파싱)
3. DOM 및 CSSOM을 결합하여 렌더 트리를 형성한다. (Attatchment)
4. 렌더 트리에서 레이아웃을 실행하여 각 노드의 형태를 계산한다. (Layout)
5. 개별 노드를 화면에 페인팅 한다. (Painting)
- composite만 작동하는 css를 활용하면 애니메이션 최적화가 가능하다.




출처

["HowBrowsersWork: Behindthescenesofmodernwebbrowsers"](http://www.html5rocks.com/en/tutorials/internals/howbrowserswork/)
[브라우저는 어떻게 동작하는가](https://d2.naver.com/helloworld/59361)
