## 절차적 프로그래밍

- 반복되는 동작을 함수 및 프로시저 형태로 모듈화 하여 사용하는 방식
    - 절차 = 함수
    - 프로시저 : 리턴값이 없는 함수 (ex. `printf` : 데이터 출력 용도)
- 반복 동작을 모듈화 하여 코드를 줄일 수 있음
- 자료형과 함수를 따로 생각하고 구현하기 때문에 논리적으로 묶여 있지 않아 연관 여부를 바로 알아차리기 어려움

<br />

## 객체 지향 프로그래밍 (OOP : Object Oriented Programming)

- 필요한 데이터를 추상화시켜 상태와 행위를 가진 객체를 만들고 그 객체들 간의 유기적인 상호작용을 통해 로직을 구성하는 프로그래밍 방법
- 가능한 모든 물리적, 논리적 요소를 객체로 만드는 것으로, 객체 내부에 자료형 필드와 함수가 함께 존재
- 어떤 개념에 대한 자료형과 함수를 ‘객체’ 형태로 함께 묶어서 관리하기 위함
- 객체 간의 독립성이 뚜렷하게 생기고 중복되는 코드의 양이 줄어듦 → 유지보수에 용이

### 객체 지향 언어 기준

1. 캡슐화, 다형성, 클래스 상속을 지원하는가?
2. 데이터 접근 제한을 걸 수 있는가?

<br />

## 객체 지향 프로그래밍 특징

### 추상화 (Abstraction)

> 객체의 공통적인 속성과 기능을 추출하여 정의하는 것
> 

### 캡슐화 (Encapsulation)

> 정보 은닉화를 통해 **높은 응집도, 낮은 결합도**를 유지할 수 있도록 설계하는 것
> 
- 은닉화 : 객체 내부의 어떤 동작에 대한 구현이 어떻게 되어 있는지 감추는 것
- 객체 각각은 독립적으로 작용할 수 있도록 응집도가 강해야 하고, 다른 모듈을 참조하는 결합도는 낮아야 함
    - 응집도 : 모듈 내부 구성요소 간 연관 정도, 모듈의 독립성을 나타냄
    - 결합도 : 모듈과 모듈 간 상호 의존 정도
- 외부에서 접근할 필요가 없는 것들은 접근 지정자를 `private` 으로 두어 접근에 제한

### 상속 (Inheritance)

> 상위 개념의 특징을 하위 개념이 물려받아 사용하는 것
> 
- 재사용으로 인해 코드 길이가 줄어듦
- `IS-A` 관계 성립할 때 사용
    - IS-A : 포함 관계. 클래스 A 가 클래스 B 의 자식 클래스 (ex. 강아지는 동물이다.)
    - HAS-A : 구성(Composition) 관계. 한 객체가 다른 객체에 속함 (ex. 컴퓨터 안에 CPU 가 있다.)
- 재사용 관점 X, 기능의 확장 관점 O

### 다형성 (Polymorphism)

> 하나의 객체가 여러가지 타입을 가질 수 있는 것
> 
- 자바에서는 부모 클래스 타입의 참조 변수로 자식 클래스 타입의 인스턴스를 참조할 수 있도록 하여 구현
- **오버로딩 (Overloading)**
    - 새로운 메소드 정의
    - 이름은 같지만 매개변수의 타입이나 개수가 다름
- **오버라이딩 (Overriding)**
    - 상속 받은 기존의 메소드 재정의
    - 부모 클래스의 메소드와 구성 요소 모두가 동일해야 함

|  | 오버로딩 | 오버라이딩 |
| --- | --- | --- |
| 메소드명 | 동일 | 동일 |
| 매개변수 및 타입 | 다름 | 동일 |
| 리턴 타입 | 관계 없음 | 동일 |

<br />

### 장점

- 생산성 향상
    - 잘 설계된 클래스를 만들어 독립적인 객체를 사용함으로서 개발의 생산성 향상
    - 상속, 캡슐화, 다형성으로 인해 코드를 재사용하기 쉬움
- 쉬운 모델링
    - 일상의 구조가 객체에 자연스럽게 녹아들어 있어 생각하고 있는 것을 그대로 자연스럽게 구현 가능
- 유지보수의 우수성
    - 기능 수정 시 함수를 새롭게 바꾸더라도 캡슐화와 함수의 세부정보가 은폐되어 있어 주변에 미치는 영향 최소화
    - 객체 종류 추가 시 상속을 통하여 기존 기능을 활용하고 새로운 속성만 추가하면 되므로 경제적

### 단점

- 느린 개발 속도
    - 코드를 잘 나누고 설계하는 것이 어려움
- 느린 실행 속도
    - 캡슐화와 격리구조 때문에 절차적 프로그래밍에 비해 실행 속도가 느림
    - 모든 것을 객체로 생각하기 때문에 메모리와 연산에 대한 비용 증가

<br />

## 객체 지향 설계 원칙 (SOLID)

### 단일 책임 원칙 (SRP : Single Responsibility Principle)

> 하나의 클래스는 하나의 책임만 가져야 한다.
> 
- 좋은 객체 지향 설계를 위해서는 기본적으로 하나의 클래스에는 수행할 수 있는 하나의 책임(기능)을 가져야 함
- 하나의 클래스가 책임이 많아지면 클래스 내부의 함수끼리 강한 결합력을 가지게 되므로 책임을 분리시킬 필요가 있음
    - 변화에 대한 유연성 확보
    - 낮은 결합도, 높은 응집도 추구

### 개방-폐쇄 원칙 (OCP : Open-Closed Principle)

> 모듈은 확장에는 열려 있으나, 변경에는 닫혀 있어야 한다.
> 
- 기존의 코드를 변경하지 않고 기능을 수정하거나 추가할 수 있도록 설계해야 함
- 추상화(인터페이스)와 상속(다형성) 등을 통해 구현해낼 수 있음. 자주 변화하는 부분을 추상화 함으로서 기존 코드를 수정하지 않고도 기능을 확장할 수 있도록 하여 유연함을 높여야 함
- 이를 지키지 않으면, 유연성, 재사용성, 유지보수성을 모두 잃어버리게 됨

### 리스코프 치환 원칙 (LSP : Liskov Substitution Principle)

> 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다.
> 
- 다형성에서 하위 클래스는 상위 클래스의 기능을 모두 수행할 수 있어야 함
- 부모 클래스의 인스턴스 대신 자식 클래스의 인스턴스를 사용해도 문제 없어야 함
- 부모 클래스와 자식 클래스 사이에는 ‘일관성’ 이 있어야 함
    - 상속 관계에서는 꼭 일반화 관계(`IS-A`)가 성립해야 함 (일관성 있는 관계인가)
    - 상속 관계가 아닌 클래스들을 상속 관계로 설정하면 원칙 위배 (재사용 목적으로 사용하는 경우)

### 인터페이스 분리 원칙 (ISP : Interface Segregation Principle)

> 하나의 일반적인 인터페이스보다는, 여러 개의 구체적인 인터페이스가 낫다.
> 
- 인터페이스에 최소한의 메소드를 구현하여 최소한의 기능만 제공
- 클래스는 자신이 사용하지 않는 인터페이스는 구현하지 않아야 함

### 의존 역전 원칙 (DIP : Dependency Inversion Principle)

> 의존 관계를 맺을 때, 변하기 쉬운 것(구체적인 것) 보다는 변하기 어려운 것(추상적인 것)에 의존해야 한다.
> 
- 구체화된 클래스 보다는 추상 클래스나 인터페이스에 의존해야 함
- 상위 클래스일수록, 인터페이스일수록, 추상 클래스일수록 변하지 않을 가능성이 높기에 하위 클래스나 구체 클래스가 아닌 상위 클래스, 인터페이스, 추상 클래스를 통해 의존하라는 것
